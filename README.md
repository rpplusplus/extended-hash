数据库课程设计: 可扩展哈希
=======================

###1. 实验平台
>Linux 或者 Windows

###2. 编程语言
>仅能使用 C/C++,不允许使用 STL。

###3. 实现算法
>可扩展哈希,具体算法请见课件<lec7 Hash-Based Indexes>中的第 5 至 12 张。 

>算法实现分为两大部分,第一部分是建立索引,第二部分是查询。建立索引是将输入的每一条记录根据指定的键值放入合适的哈希桶内,当哈希桶已满时,需要进行分裂。查询是 根据输入的键值返回具有相同键值的记录,返回的记录可能有不止一条。

###4. 实现过程
>(1) 读入由 tpc-h 生成的 lineitem.tbl,以 L_ORDERKEY 属性作为键值将记录放入合适的哈希桶
内。

>(2) 读入测试文件 testinput.in 内的数据,数据中包含多个需要查询的键值,具体格式请见[6.
数据输入输出说明]。

>(3) 将通过键值查询得到的所有记录都输出到 testoutput.out 文件中,具体格式请见[6. 数据输入输出说明]。

###5. 实现细节
>(1) 只能使用 P 个页,每个页的大小为 8K bytes,一个哈希桶的大小和一个页的大小相同。
考虑以下两种情况:
>>a) P=8(也就是整个内存中仅能使用 8 个页,这 8 个页用于存放索引和哈希
桶的数据)  

>>b) P=128(也就是整个内存中仅能使用 128 个页,这 128 个页用于存放索引
和哈希桶的数据)

>由于页的数量有所限制,lineitem.tbl 的数据和对其建立的索引不可能都放在内存里, 所以频繁的文件读写(I/O)是不可避免的。请比较P=8和P=128两种情况下,I/O的次数、目录的大小、哈希桶的数量、查询的速度(每秒执行查询的数量)、I/O 用时占 查询总用时的比例等。

>(2) 对于哈希桶内的数据,采用<键,数据记录>的方式进行存储。详细内容请参考课件 <lec3 File and Indexing>中的第 16、17 张。

>(3) 对于存储哈希桶数据的页面,使用变长记录的方式进行存储。关于变长记录,请参 考课件<lec 3 Storing Data>中的第 31 张。

>(4) 使用时钟页面算法进行页面置换,请参考<lec 3 Storing Data>中的第 19 张。

>(5) 分别实现从低位和从高位进行扩展的哈希。详细内容请参考课件<lec 7 Hash-Based Indexes>中的第 10 张。比较这两种哈希方法,包括桶的分裂方式、桶分裂时桶内数的分配方式、I/O 的次数、目录的大小、桶的数量、查询的速度(每秒执行查询的数量)、I/O 用时占查询总用时的比例等。

>(6) 将建立的哈希索引输出到新的文件中,命名为 hashindex.out,格式自定。

>(7) 对于每个查询结果,请按照L_PARTKEY属性的值进行排序。

###6. 数据输入输出说明
>将文件路径作为启动参数传入程序,例如执行 ExtendibleHash.exe 程序, 执行命令为“ExtendibleHash.exe D:\database”。该路径表示 lineitem.tbl 和 testinput.in所在的文件路径, 同时也表示 testoutput.out 和 hashindex.out 输出的文件路径。以下是对文件的格式进行说明, 请严格按照文件格式进行输入输出。hashindex.out格式自定,因此不作说明。

>#####(1) lineitem.tbl

>通过 tpc-h 的 dbgen 程序生成,Scale Factor 设置为 1,所以记录的数量一定是 6001215。 选择 L_ORDERKEY 属性作为键值建立哈希索引。

>#####(2) testinput.in

>数据第一行是n,表示查询数量。接下来的 n 行,每行分别是一个整数,表示要查询的键值。

>#####(3) testoutput.out

>对于每一个查询,输出所有满足要求的记录,并且按照 L_PARTKEY 属性的值进行排 序。每行一条记录。对于每个查询的结果,都以-1 作为结束。